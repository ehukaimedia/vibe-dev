# TDD Mock Implementation Fix - Next Session

## For Next Session Developer
**Priority**: Fix Jest mocking to unblock test suite
**Goal**: Get all tests passing using TDD methodology to incrementally achieve README promises

## Current State
- ✅ TypeScript errors fixed (format parameter, async functions)
- ❌ 73/160 tests failing due to mock implementation issues
- ❌ Real terminal sessions being created during tests
- ❌ Jest not exiting cleanly (hanging processes)

## TDD Approach - RED → GREEN → REFACTOR

### Step 1: RED - Identify Failing Test Pattern
The core issue is that `jest.mock()` isn't intercepting ES module imports. Example:

```typescript
// This mock is NOT working:
jest.mock('../../src/vibe-terminal.js');

// Real terminal is being created instead of mock
const terminal = getTerminal(); // Creates actual PTY session!
```

### Step 2: GREEN - Minimal Fix to Make Tests Pass

**Option A: Use unstable_mockModule (Recommended)**
```typescript
// test/unit/recap-coverage.test.ts
import { jest } from '@jest/globals';

// Mock BEFORE any imports
await jest.unstable_mockModule('../../src/vibe-terminal.js', () => ({
  getTerminal: jest.fn(() => mockTerminal),
  executeTerminalCommand: jest.fn()
}));

// Import AFTER mock
const { generateRecap } = await import('../../src/vibe-recap.js');
```

**Option B: Dependency Injection Pattern**
```typescript
// src/vibe-recap.ts - Add optional parameter
export async function generateRecap(
  args: RecapArgs,
  terminal = getTerminal() // Inject dependency
): Promise<string> {
  // Use injected terminal
}

// test/unit/recap.test.ts - Pass mock
const recap = await generateRecap(args, mockTerminal);
```

### Step 3: REFACTOR - Apply Pattern to All Tests

## Incremental Implementation Plan

### Phase 1: Fix Core Mock Issue (1-2 hours)
1. **Pick ONE failing test file** (suggest `recap-coverage.test.ts`)
2. **Apply mock fix** using Option A or B
3. **Verify tests pass** for that file
4. **Document the working pattern**

### Phase 2: Apply Pattern Systematically (2-3 hours)
Fix tests in this order (easiest to hardest):
1. `server.test.ts` - Already using manual mocks
2. `recap.test.ts` - Similar to recap-coverage
3. `index.test.ts` - Mock StdioServerTransport
4. `vibe-terminal-coverage.test.ts` - Mock node-pty

### Phase 3: Clean Up Test Infrastructure (1 hour)
1. Add `--detectOpenHandles` to find hanging processes
2. Ensure all tests properly cleanup
3. Remove any Windows-specific test code
4. Verify `npm test` exits cleanly

### Phase 4: Verify Coverage & Quality (30 min)
1. Run `npm run test:coverage`
2. Identify uncovered code paths
3. Add missing tests using TDD
4. Aim for >90% coverage

## Test Commands for Each Phase

```bash
# Phase 1 - Test single file
npm test test/unit/recap-coverage.test.ts

# Phase 2 - Test each fixed file
npm test test/unit/server.test.ts
npm test test/unit/recap.test.ts
npm test test/unit/index.test.ts
npm test test/unit/vibe-terminal-coverage.test.ts

# Phase 3 - Find hanging handles
npm test -- --detectOpenHandles

# Phase 4 - Check coverage
npm run test:coverage
```

## Success Criteria for Each Phase

### Phase 1 Success:
- `recap-coverage.test.ts` passes (12/12 tests)
- No real terminal sessions created
- Pattern documented for other tests

### Phase 2 Success:
- All 4 core test files passing
- Mock pattern consistently applied
- No TypeScript errors

### Phase 3 Success:
- `npm test` exits cleanly
- No hanging processes
- All cleanup in afterEach()

### Phase 4 Success:
- 160/160 tests passing
- Coverage > 90%
- Ready for production

## Key Code Pattern to Apply

```typescript
// BEFORE (not working)
jest.mock('../../src/module.js');
import { something } from '../../src/module.js';

// AFTER (working)
const mockSomething = jest.fn();
jest.mock('../../src/module.js', () => ({
  something: mockSomething
}));
import { something } from '../../src/module.js';

// Or with unstable_mockModule
await jest.unstable_mockModule('../../src/module.js', () => ({
  something: jest.fn()
}));
const { something } = await import('../../src/module.js');
```

## Remember: TDD Cycle
1. **See test fail** (it already is)
2. **Make it pass** (minimal mock fix)
3. **Refactor** (apply pattern everywhere)
4. **Repeat** for each test file

## Final Goal
By end of session, we should have:
- All tests passing (160/160)
- No hanging processes
- Clean mock implementation
- Coverage report showing >90%
- Foundation ready for achieving 100% of README promises

The README promises bulletproof, enterprise-grade terminal operations. Our tests must prove we deliver on that promise!